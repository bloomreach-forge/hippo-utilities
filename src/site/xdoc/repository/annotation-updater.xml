<?xml version="1.0"?>
<!--
  Copyright 2012-2013 Hippo B.V. (http://www.onehippo.com)

  Licensed under the Apache License, Version 2.0 (the "License");
  you may not use this file except in compliance with the License.
  You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

  Unless required by applicable law or agreed to in writing, software
  distributed under the License is distributed on an "AS IS" BASIS,
  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  See the License for the specific language governing permissions and
  limitations under the License.
  -->

<!DOCTYPE document PUBLIC "-//Apache Software Foundation//DTD XDOC 1.0//EN" "http://maven.apache.org/dtd/xdoc_1_0.dtd">
<document>
  <properties>
    <title>Hippo Utilities Repository - Annotation Base Updater Module</title>
  </properties>
  <body>
    <section name="Annotation Base Updater Module">
      <subsection name="AnnotationBaseUpdater implements UpdaterModule">
        <p>
          AnnotationBaseUpdater supports @Updater, @PathVisitor and @QueryVisitor
          for your convenience. So you can easily implement your custom updater
          only by using annotations!
        </p>
        <p>
          <em>Note: you may read the articles in the <a href="#References">References</a> for detail about the concept of UpdaterModule itself.</em>
        </p>
        <p>
          You may define @PathVisitor or/and @QueryVisitor in any methods
          which should be public and have only one parameter of javax.jcr.Node type.
        </p>
        <p>
          Here is a simple example:
        </p>
        <source><![CDATA[
@Updater(name = "Updater-demosite-2.05.00",
        start = { "demosite-2.04.00" },
        end = { "demosite-2.05.00" })
public class Updater_2_05_00 extends AnnotationBaseUpdater {

    @PathVisitor(
            paths={
                    "/hippo:configuration/hippo:initialize/hippo-namespaces-demosite-comment",
                    "/hippo:configuration/hippo:initialize/demosite-sitemap"
                }
            )
    public void deleteInitializeNodes(Node node) throws RepositoryException { node.remove(); }

    @PathVisitor(
            paths={
                    "/hippo:namespaces/demosite/comment",
                    "/hst:hst/hst:configurations/demosite/hst:sitemap"
                }
            )
    public void deleteNamespaceConfigurationNodes(Node node) throws RepositoryException { node.remove(); }
}
        ]]></source>
        <p>
          In the example above, the updater class defines its name and start/end version tags.
          So, the updater will run on the system having 'demosite-2.04.00' value in '/hippo:configuration/hippo:initialize' node.
          After running the updater, the repository will have a new tag version, 'demosite-2.05.00' value in the node.
        </p>
        <p>
          The example updater implementation shown above defines two methods, both of which must be public and have only one javax.jcr.Node type argument.
          The first method, #deleteInitializeNodes(Node), is annotated by @PathVisitor, so AnnotationBaseUpdater will automatically register visitors by the paths
          and the visitors will invoke the #deleteInitializeNodes(Node) automatically.
          In the example, it just removes the visiting nodes in order to re-initialize the initialize items.
        </p>
        <p>
          Also, the #deleteNamespaceConfigurationNodes(Node) method defines @PathVisitor annotation as well in order to remove namespace nodes and configuration nodes.
          Anyway, you can define any methods with @PathVisitor or @QueryVisitor. AnnotationBaseUpdater will register visitors to invoke your methods automatically.
        </p>
      </subsection>
      <subsection name="Annotations in Detail">
        <p>
          All annotation types are defined in "org.onehippo.forge.utilities.repository.updater.annotations" package.
        </p>
        <table>
          <tr>
            <th>Annotation Type</th>
            <th>Element</th>
            <th>Description</th>
            <th>Required?</th>
            <th>Example Value</th>
            <th>Default Value</th>
          </tr>
          <tr>
            <td>Updater</td>
            <td></td>
            <td>Updater marker annotation for your class</td>
            <td>Yes</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>Updater</td>
            <td>name</td>
            <td>
              The name of your updater.
              This value is used to invoke UpdaterContext#registerName(name);
            </td>
            <td>Yes</td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>Updater</td>
            <td>start</td>
            <td>
              The start tags of your updater.
              This value is type of String array.
              Each item of this value is used to invoke UpdaterContext#registerStartTag(tag);
              <br/>
              The start tag values define the previous tag values in your repository.
              If your repository has any of the start tag value, then your updater will run.
              <br/>
              So, in order to run your updater, the repository should already have any of the start tags.
            </td>
            <td>Yes</td>
            <td>demosite-2.04.00</td>
            <td></td>
          </tr>
          <tr>
            <td>Updater</td>
            <td>end</td>
            <td>
              The end tags of your updater.
              This value is type of String array.
              Each item of this value is used to invoke UpdaterContext#registerEndTag(tag);
              <br/>
              The end tag values define the new tag values for your repository.
              After the updater runs successfully, your repository will have new tag values by this end tag values.
            </td>
            <td>Yes</td>
            <td>demosite-2.05.00</td>
            <td></td>
          </tr>
          <tr>
            <td>Updater</td>
            <td>before</td>
            <td>
              The before values define the execution orders among updaters.
              This value is type of String array.
              Each item of this value is used to invoke UpdaterContext#registerBefore(value);
              <br/>
              If you want to run your updater before some updaters from other plugins or modules,
              then you may set before values to the names of other updater modules.
            </td>
            <td>No</td>
            <td>Updater-plugin1-1.02.01</td>
            <td></td>
          </tr>
          <tr>
            <td>Updater</td>
            <td>after</td>
            <td>
              The after values define the execution orders among updaters, too.
              This value is type of String array.
              Each item of this value is used to invoke UpdaterContext#registerAfter(value);
              <br/>
              If you want to run your updater after some updaters from other plugins or modules,
              then you may set after values to the names of other updater modules.
            </td>
            <td>No</td>
            <td>Updater-plugin2-2.01.00</td>
            <td></td>
          </tr>
          <tr>
            <td>PathVisitor</td>
            <td></td>
            <td>
              Annotation enabling to iterate all nodes by the specified path.
              Your methods with this annotation must have only one argument
              which is type of javax.jcr.Node.
            </td>
            <td></td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>PathVisitor</td>
            <td>paths</td>
            <td>
              The path array value.
              Each of path values will be used to register path visitors.
              Path visitors are internally created to invoke your annotated method with
              the visiting javax.jcr.Node instance argument.
            </td>
            <td>Yes</td>
            <td>
              {
                "/hippo:configuration/hippo:initialize/hippo-namespaces-demosite-comment",
                "/hippo:configuration/hippo:initialize/demosite-sitemap"
              }
            </td>
            <td></td>
          </tr>
          <tr>
            <td>QueryVisitor</td>
            <td></td>
            <td>
              Annotation enabling to iterate all nodes by the specified query statements.
              Your methods with this annotation must have only one argument
              which is type of javax.jcr.Node.
            </td>
            <td></td>
            <td></td>
          </tr>
          <tr>
            <td>QueryVisitor</td>
            <td>language</td>
            <td>
              The language value for the query statements.
            </td>
            <td>No</td>
            <td>"xpath", "sql", etc.</td>
            <td>"xpath"</td>
          </tr>
          <tr>
            <td>QueryVisitor</td>
            <td>queries</td>
            <td>
              The query statement array value.
              Each of query statement values will be used to register query visitors.
              Query visitors are internally created to invoke your annotated method with
              the visiting javax.jcr.Node instance argument.
            </td>
            <td>Yes</td>
            <td>
              {
                "//some/ad-hoc/path/to/delete[@tag='something']",
                "//some/ad-hoc/path/to/delete[content:block/@color='green']"
              }
            </td>
            <td></td>
          </tr>
        </table>
      </subsection>
      <subsection name="UpdaterUtils helps you to work with JCR Nodes">
        <p>
          Also, for advanced usages, you may also use UpdaterUtils class
          which provides the following utility methods. Please see javadoc for more detail.
        </p>
        <source><![CDATA[
public class UpdaterUtils {

    public static void removeSubNode(Node node, String name);
    public static void removeProperty(Node node, String property);
    public static String getProperty(Node node, String property);
    public static String getUUID(Node node);

    public static Node setHSTPage(Node node, String name, String referenceComponent, String template);
    public static Node setHSTTemplate(Node node, String name, String renderPath);
    public static Node setHSTComponent(Node node, String name, String componentClassName,
                                       String template, String[] parameterNames, String[] parameterValues);
    public static Node setHSTSitemapItem(Node node, String name, String componentConfigurationId,
                                         String relContentPath);
    public static Node setHSTSitemenu(Node node, String name);
    public static Node setHSTSitemenuItem(Node node, String name, String referenceSitemapItem);
    public static void setHSTParameterNamesValues(Node node, String[] parameterNames, String[] parameterValues);

    public static void setPropertyNode(Node propertiesDoc, String propName, String propValue);
    public static void removePropertyNode(Node propertiesDoc, String propName);

    public static Node getFolder(Node node, String folderName);
    public static Node createFolder(Node node, String folderName);
    public static Node createFolder(Node node, String folderName, String[] folderTypes);
    public static String[] getDefaultFolderTypes();

}
        ]]></source>
      </subsection>
      <subsection name="References">
        <ul>
          <li><a href="https://wiki.onehippo.com/display/CMS7/Upgrading+and+updating">Upgrading and updating</a></li>
          <li><a href="http://blog.jeroenreijn.com/2010/06/introduction-to-hippo-cms-7-updater.html">An introduction to Hippo CMS 7 updater modules</a></li>
        </ul>
      </subsection>
    </section>
  </body>
</document>
